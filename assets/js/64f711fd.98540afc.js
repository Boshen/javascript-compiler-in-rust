"use strict";(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[242],{1973:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/ecma-spec","metadata":{"permalink":"/javascript-compiler-in-rust/blog/ecma-spec","editUrl":"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/blog/blog/ecma-spec.md","source":"@site/blog/ecma-spec.md","title":"The ECMAScript Specification","description":"The ECMAScript\xae 2023 Language Specification details everything about the JavaScript language, so anyone can implement their own JavaScript engine.","date":"2022-08-11T08:37:39.000Z","formattedDate":"August 11, 2022","tags":[],"readingTime":3.04,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"The ECMAScript Specification"},"nextItem":{"title":"Grammar","permalink":"/javascript-compiler-in-rust/blog/grammar"}},"content":"[The ECMAScript\xae 2023 Language Specification](https://tc39.es/ecma262/) details everything about the JavaScript language, so anyone can implement their own JavaScript engine.\\n\\n\x3c!--truncate--\x3e\\n\\nFor our compiler, we will study the following chapters:\\n\\n- Chapter 5 Notational Conventions\\n- Chapter 11 ECMAScript Language: Source Text\\n- Chapter 12 ECMAScript Language: Lexical Grammar\\n- Chapter 13 - 16 Expressions, Statements, Functions, Classes, Scripts and Modules\\n- Chapter B Additional ECMAScript Features for Web Browsers\\n- Chapter C The Strict Mode of ECMAScript\\n\\n## Chapter 5 Notational Conventions\\n\\n[Chapter 5.1.5 Grammar Notation](https://tc39.es/ecma262/#sec-grammar-notation) is the section you need to read.\\n\\nThe things to note here are:\\n\\n**Recursion**\\n\\nThis is how lists are presented in the grammar.\\n\\n```markup\\nArgumentList :\\n  AssignmentExpression\\n  ArgumentList , AssignmentExpression\\n```\\n\\nmeans\\n\\n```javascript\\na, b = 1, c = 2\\n^_____________^ ArgumentList\\n   ^__________^ ArgumentList, AssignmentExpression,\\n          ^___^ AssignmentExpression\\n```\\n\\n**Optional**\\nThe `_opt_` suffix for optional syntax. For example,\\n\\n```markup\\nVariableDeclaration :\\n  BindingIdentifier Initializer_opt\\n```\\n\\nmeans\\n\\n```javascript\\nvar binding_identifier;\\nvar binding_identifier = Initializer;\\n                       ______________ Initializer_opt\\n```\\n\\n**Parameters**\\n\\nThe `[Return]` and `[In]` are parameters to the grammar.\\n\\nFor example\\n\\n```markdup\\nScriptBody :\\n    StatementList[~Yield, ~Await, ~Return]\\n```\\n\\nmeans top level yield, await and return are not allow in scripts, but\\n\\n```markdup\\nModuleItem :\\n  ImportDeclaration\\n  ExportDeclaration\\n  StatementListItem[~Yield, +Await, ~Return]\\n```\\n\\nallows for top level return.\\n\\n## Chapter 11 ECMAScript Language: Source Text\\n\\n[Chapter 11.2 Types of Source Code](https://tc39.es/ecma262/#sec-types-of-source-code) tells us that\\nthere is a huge distinction between script code and module code.\\nAnd there is a `use strict` mode that makes the grammar saner by disallowing old JavaScript behaviors.\\n\\n**Script Code** is not strict, `use strict` need to be inserted at the top of the file to make script code strict.\\nIn html you write `<script src=\\"javascript.js\\"><\/script>`.\\n\\n**Module Code** is automatically strict.\\nIn html you write `<script type=\\"module\\" src=\\"main.mjs\\"><\/script>`.\\n\\n## Chapter 12 ECMAScript Language: Lexical Grammar\\n\\nFor more in depth explanation, you can read the V8 blog on [Understanding the ECMAScript spec](https://v8.dev/blog/understanding-ecmascript-part-3).\\n\\n### [Chapter 12.9 Automatic Semicolon Insertion](https://tc39.es/ecma262/#sec-automatic-semicolon-insertion)\\n\\nThis section describes all the rules that you need can omit a semicolon while writing JavaScript.\\nAll the explanation boils down to\\n\\n```rust\\n    pub fn asi(&mut self) -> Result<()> {\\n        if self.eat(Kind::Semicolon) || self.can_insert_semicolon() {\\n            return Ok(());\\n        }\\n        let range = self.prev_node_end..self.cur_token().start;\\n        Err(SyntaxError::AutoSemicolonInsertion(range.into()))\\n    }\\n\\n    pub const fn can_insert_semicolon(&self) -> bool {\\n        self.cur_token().is_on_new_line || matches!(self.cur_kind(), Kind::RCurly | Kind::Eof)\\n    }\\n```\\n\\nand in parser code\\n\\n```rust\\n    fn parse_debugger_statement(&mut self) -> Result<Statement<\'a>> {\\n        let node = self.start_node();\\n        self.expect(Kind::Debugger)?;\\n        // highlight-next-line\\n        self.asi()?;\\n        self.ast.debugger_statement(self.finish_node(node))\\n    }\\n```\\n\\n:::info\\n\\nThis section on asi is written with a parser in mind,\\nit explicitly states that the source text is parsed from left to right,\\nwhich makes it almost impossible to write the parser in any other way.\\nThe author of jsparagus made a rant about this [here](https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#automatic-semicolon-insertion-).\\n\\n> The specification for this feature is both very-high-level and weirdly procedural (\u201cWhen, as the source text is parsed from left to right, a token is encountered...\u201d, as if the specification is telling a story about a browser. As far as I know, this is the only place in the spec where anything is assumed or implied about the internal implementation details of parsing.) But it would be hard to specify ASI any other way.\\n\\n:::\\n\\n## Chapter 13 - 16 Expressions, Statements, Functions, Classes, Scripts and Modules\\n\\n### Identifiers\\n\\nDistinguish between an identifier reference and binding identifier.\\n\\n### Expressions\\n\\nPratt parsing.\\n\\n### Parenthesized Expression\\n\\nMeaningless expect this one litter corner ... https://github.com/estree/estree/issues/194\\n\\n### Cover Grammar\\n\\nCover grammar will be your first painful experience while understanding JavaScript from a parser point of view.\\nRead the [intro V8 blog post](https://v8.dev/blog/understanding-ecmascript-part-4) on this topic first,\\nand I\'ll cover this in [this tutorial](/blog/grammar).\\n\\n### Restricted Productions\\n\\nParse `/` and templates.\\n\\n### Arrow functions"},{"id":"/grammar","metadata":{"permalink":"/javascript-compiler-in-rust/blog/grammar","editUrl":"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/blog/blog/grammar.md","source":"@site/blog/grammar.md","title":"Grammar","description":"Cover Grammar","date":"2022-08-11T08:37:39.000Z","formattedDate":"August 11, 2022","tags":[],"readingTime":0.045,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Grammar"},"prevItem":{"title":"The ECMAScript Specification","permalink":"/javascript-compiler-in-rust/blog/ecma-spec"}},"content":"### Cover Grammar\\n\\n### Grammar Context\\n\\n### Ambiguous Grammar"}]}')}}]);