"use strict";(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[242],{1973:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/ecma-spec","metadata":{"permalink":"/javascript-compiler-in-rust/blog/ecma-spec","editUrl":"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/blog/blog/ecma-spec.md","source":"@site/blog/ecma-spec.md","title":"The ECMAScript Specification","description":"The ECMAScript\xae 2023 Language Specification details everything about the JavaScript language, so anyone can implement their own JavaScript engine.","date":"2022-08-12T05:53:49.000Z","formattedDate":"August 12, 2022","tags":[],"readingTime":3.025,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"The ECMAScript Specification"},"nextItem":{"title":"Grammar","permalink":"/javascript-compiler-in-rust/blog/grammar"}},"content":"[The ECMAScript\xae 2023 Language Specification](https://tc39.es/ecma262/) details everything about the JavaScript language, so anyone can implement their own JavaScript engine.\\n\\n\x3c!--truncate--\x3e\\n\\nFor our compiler, we will study the following chapters:\\n\\n- Chapter 5 Notational Conventions\\n- Chapter 11 ECMAScript Language: Source Text\\n- Chapter 12 ECMAScript Language: Lexical Grammar\\n- Chapter 13 - 16 Expressions, Statements, Functions, Classes, Scripts and Modules\\n- Chapter B Additional ECMAScript Features for Web Browsers\\n- Chapter C The Strict Mode of ECMAScript\\n\\n## Chapter 5 Notational Conventions\\n\\n[Chapter 5.1.5 Grammar Notation](https://tc39.es/ecma262/#sec-grammar-notation) is the section you need to read.\\n\\nThe things to note here are:\\n\\n**Recursion**\\n\\nThis is how lists are presented in the grammar.\\n\\n```markup\\nArgumentList :\\n  AssignmentExpression\\n  ArgumentList , AssignmentExpression\\n```\\n\\nmeans\\n\\n```javascript\\na, b = 1, c = 2\\n^_____________^ ArgumentList\\n   ^__________^ ArgumentList, AssignmentExpression,\\n          ^___^ AssignmentExpression\\n```\\n\\n**Optional**\\nThe `_opt_` suffix for optional syntax. For example,\\n\\n```markup\\nVariableDeclaration :\\n  BindingIdentifier Initializer_opt\\n```\\n\\nmeans\\n\\n```javascript\\nvar binding_identifier;\\nvar binding_identifier = Initializer;\\n                       ______________ Initializer_opt\\n```\\n\\n**Parameters**\\n\\nThe `[Return]` and `[In]` are parameters of the grammar.\\n\\nFor example\\n\\n```markdup\\nScriptBody :\\n    StatementList[~Yield, ~Await, ~Return]\\n```\\n\\nmeans top-level yield, await and return are not allowed in scripts, but\\n\\n```markdup\\nModuleItem :\\n  ImportDeclaration\\n  ExportDeclaration\\n  StatementListItem[~Yield, +Await, ~Return]\\n```\\n\\nallows for top-level return.\\n\\n## Chapter 11 ECMAScript Language: Source Text\\n\\n[Chapter 11.2 Types of Source Code](https://tc39.es/ecma262/#sec-types-of-source-code) tells us that\\nthere is a huge distinction between script code and module code.\\nAnd there is a `use strict` mode that makes the grammar saner by disallowing old JavaScript behaviors.\\n\\n**Script Code** is not strict, `use strict` need to be inserted at the top of the file to make script code strict.\\nIn html you write `<script src=\\"javascript.js\\"><\/script>`.\\n\\n**Module Code** is automatically strict.\\nIn html you write `<script type=\\"module\\" src=\\"main.mjs\\"><\/script>`.\\n\\n## Chapter 12 ECMAScript Language: Lexical Grammar\\n\\nFor more in-depth explanation, you can read the V8 blog on [Understanding the ECMAScript spec](https://v8.dev/blog/understanding-ecmascript-part-3).\\n\\n### [Chapter 12.9 Automatic Semicolon Insertion](https://tc39.es/ecma262/#sec-automatic-semicolon-insertion)\\n\\nThis section describes all the rules that you need can omit a semicolon while writing JavaScript.\\nAll the explanation boils down to\\n\\n```rust\\n    pub fn asi(&mut self) -> Result<()> {\\n        if self.eat(Kind::Semicolon) || self.can_insert_semicolon() {\\n            return Ok(());\\n        }\\n        let range = self.prev_node_end..self.cur_token().start;\\n        Err(SyntaxError::AutoSemicolonInsertion(range.into()))\\n    }\\n\\n    pub const fn can_insert_semicolon(&self) -> bool {\\n        self.cur_token().is_on_new_line || matches!(self.cur_kind(), Kind::RCurly | Kind::Eof)\\n    }\\n```\\n\\nand in parser code\\n\\n```rust\\n    fn parse_debugger_statement(&mut self) -> Result<Statement<\'a>> {\\n        let node = self.start_node();\\n        self.expect(Kind::Debugger)?;\\n        // highlight-next-line\\n        self.asi()?;\\n        self.ast.debugger_statement(self.finish_node(node))\\n    }\\n```\\n\\n:::info\\n\\nThis section on asi is written with a parser in mind,\\nit explicitly states that the source text is parsed from left to right,\\nwhich makes it almost impossible to write the parser in any other way.\\nThe author of jsparagus made a rant about this [here](https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#automatic-semicolon-insertion-).\\n\\n> The specification for this feature is both very-high-level and weirdly procedural (\u201cWhen, as the source text is parsed from left to right, a token is encountered...\u201d, as if the specification is telling a story about a browser. As far as I know, this is the only place in the spec where anything is assumed or implied about the internal implementation details of parsing.) But it would be hard to specify ASI any other way.\\n\\n:::\\n\\n## Chapter 13 - 16 Expressions, Statements, Functions, Classes, Scripts and Modules\\n\\n### Identifiers\\n\\nDistinguish between an identifier reference and binding identifier.\\n\\n### Expressions\\n\\nPratt parsing.\\n\\n### Parenthesized Expression\\n\\nMeaningless expect this one litter corner ... https://github.com/estree/estree/issues/194\\n\\n### Cover Grammar\\n\\nCover grammar will be your first painful experience while understanding JavaScript from a parser point of view.\\nRead the [intro V8 blog post](https://v8.dev/blog/understanding-ecmascript-part-4) on this topic first,\\nand I\'ll cover this in [this tutorial](/blog/grammar).\\n\\n### Restricted Productions\\n\\nParse `/` and templates.\\n\\n### Arrow functions"},{"id":"/grammar","metadata":{"permalink":"/javascript-compiler-in-rust/blog/grammar","editUrl":"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/blog/blog/grammar.md","source":"@site/blog/grammar.md","title":"Grammar","description":"LL(1) Grammar","date":"2022-08-12T05:53:49.000Z","formattedDate":"August 12, 2022","tags":[],"readingTime":2.265,"hasTruncateMarker":false,"authors":[],"frontMatter":{"title":"Grammar"},"prevItem":{"title":"The ECMAScript Specification","permalink":"/javascript-compiler-in-rust/blog/ecma-spec"}},"content":"## LL(1) Grammar\\n\\nAccording to wikipedia,\\n\\n> an LL grammar is a context-free grammar that can be parsed by an LL parser, which parses the input from Left to right\\n\\nThe first **L** means the scanning the source from **L**eft to right,\\nand the second **L** means the construction of a **L**eftmost derivation tree.\\n\\nContext-free and the (1) in LL(1) means a tree can be constructed by just peeking at the next token and nothing else.\\n\\nLL Grammars are of particular interest in academia because we are lazy human beings and we want to write programs that generate parsers automatically so we don\'t need to write parsers by hand.\\n\\nUnfortunately most industrial programming languages do not have a nice LL(1) grammar,\\nand this applies to JavaScript too.\\n\\n:::info\\nMozilla started the [jsparagus](https://github.com/mozilla-spidermonkey/jsparagus) project a few years ago,\\nand wrote a [LALR parser generator in Python](https://github.com/mozilla-spidermonkey/jsparagus/tree/master/jsparagus).\\nThey haven\'t updated it much in the past two years and they sent a strong message at the end of [js-quirks.md](https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md)\\n\\n> What have we learned today?\\n>\\n> - Do not write a JS parser.\\n> - JavaScript has some syntactic horrors in it. But hey, you don\'t make the world\'s most widely used programming language by avoiding all mistakes. You do it by shipping a serviceable tool, in the right circumstances, for the right users.\\n\\n:::\\n\\n---\\n\\nWhat we have learned so far is that a JavaScript parser can only be written by hand,\\nso let\'s learn all the quirks in the grammar before we shoot ourselves in the foot.\\n\\nThe list below starts simple and will become difficult to grasp,\\nso please take your time.\\n\\n## Class and strict mode\\n\\nclass is strict, but there is not scope ...\\n\\n## Legacy Octal and Use Strict\\n\\n```javascript\\n\\"\\\\01\\";\\n\\"use strict\\";\\n```\\n\\nis syntax error\\n\\n## ES2016 non-simple parameter argument and strict mode\\n\\n```javascript\\nfunction foo({a}) {\\n    \'use strict\';\\n}\\n```\\n\\nis syntax error\\n\\nbut ... if you are writing a transpiler, e.g. TypeScript, this is not syntax if you are targeting es5.\\n\\n## FunctionDeclarations in IfStatement Statement Clauses\\n\\n[B.3.3 FunctionDeclarations in IfStatement Statement Clauses](https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses)\\n\\nwe need FunctionDeclarations in Statement ...\\n\\n### Label statement is legit\\n\\n```\\nconst foo => { foo: bar }\\n```\\n\\nis legit\\n\\n## `let` is not a keyword\\n\\nyou need about a dozen checks to make sure you are on a let declaration ...\\n\\n## For-of\\n\\n`for (let in ...)`\\n`for (async of ..)`\\n\\n### B.3.2 Block-Level Function Declarations Web Legacy Compatibility Semantics\\n\\n[B.3.2 Block-Level Function Declarations Web Legacy Compatibility Semantics](https://tc39.es/ecma262/#sec-block-level-function-declarations-web-legacy-compatibility-semantics)\\n\\n## Ambiguous Grammar\\n\\n`/` slash and `/=` regex\\n\\n## Grammar Context\\n\\nyield ... await ...\\n\\n## Cover Grammar\\n\\n### Arrow functions\\n\\n### Object Patter vs Object binding\\n\\n### Assignment target pattern"}]}')}}]);