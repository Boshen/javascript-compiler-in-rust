(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[927],{1298:(e,r,t)=>{"use strict";t.r(r),t.d(r,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>n,metadata:()=>l,toc:()=>u});var o=t(2081),a=(t(9496),t(9613)),i=t(9073);const n={id:"architecture",title:"Architecture Overview"},c=void 0,l={unversionedId:"architecture",id:"architecture",title:"Architecture Overview",description:"For our book, we will be applying the standard compiler frontend phases:",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/javascript-compiler-in-rust/docs/architecture",draft:!1,editUrl:"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/docs/docs/architecture.md",tags:[],version:"current",frontMatter:{id:"architecture",title:"Architecture Overview"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/javascript-compiler-in-rust/docs/intro"},next:{title:"Lexer",permalink:"/javascript-compiler-in-rust/docs/lexer"}},s={},u=[{value:"Performance",id:"performance",level:2}],p={toc:u};function d(e){let{components:r,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"For our book, we will be applying the standard compiler frontend phases:"),(0,a.kt)(i.Mermaid,{config:{},chart:"flowchart LR;\n    id[Source Text] --\x3e Token --\x3e Lexer --\x3e Parser --\x3e AST",mdxType:"Mermaid"}),(0,a.kt)("p",null,"Writing a JavaScript parser is fairly easy,\nit is 10% architectural decisions and 90% hard work on the fine-grained details."),(0,a.kt)("p",null,"The architectural decisions will mostly affect two categories:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the performance of your compiler"),(0,a.kt)("li",{parentName:"ul"},"how nice it is to consume your AST")),(0,a.kt)("p",null,"Knowing all the options and trade-offs before building a compiler in Rust will make your whole journey much smoother."),(0,a.kt)("h2",{id:"performance"},"Performance"),(0,a.kt)("p",null,"The key to a performant Rust program is to ",(0,a.kt)("strong",{parentName:"p"},"allocate less memory")," and ",(0,a.kt)("strong",{parentName:"p"},"use fewer CPU cycles"),"."),(0,a.kt)("p",null,"It is mostly transparent where memory allocations are made just by looking for heap-allocated objects such as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Vec")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Box"),".\nReasoning about their usage will give you a sense of how fast your program will be - the more you allocate, you slower your program will be."),(0,a.kt)("p",null,"Rust gives us zero-cost abstraction for free, we don't need to worry too much about abstractions causing slower performance.\nBe careful with your algorithmic complexities and you will be all good to go."))}d.isMDXComponent=!0},1965:(e,r,t)=>{var o={"./locale":2642,"./locale.js":2642};function a(e){var r=i(e);return t(r)}function i(e){if(!t.o(o,e)){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}return o[e]}a.keys=function(){return Object.keys(o)},a.resolve=i,e.exports=a,a.id=1965}}]);