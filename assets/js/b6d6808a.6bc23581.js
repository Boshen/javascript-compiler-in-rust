"use strict";(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[4],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(9496);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,k=d["".concat(l,".").concat(m)]||d[m]||u[m]||i;return n?r.createElement(k,o(o({ref:t},c),{},{components:n})):r.createElement(k,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2351:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(2081),a=(n(9496),n(9613));const i={id:"lexer",title:"Lexer"},o=void 0,s={unversionedId:"lexer",id:"lexer",title:"Lexer",description:"Token",source:"@site/docs/lexer.md",sourceDirName:".",slug:"/lexer",permalink:"/javascript-compiler-in-rust/docs/lexer",draft:!1,editUrl:"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/docs/docs/lexer.md",tags:[],version:"current",frontMatter:{id:"lexer",title:"Lexer"},sidebar:"tutorialSidebar",previous:{title:"Architecture Overview",permalink:"/javascript-compiler-in-rust/docs/architecture"},next:{title:"Abstract Syntax Tree",permalink:"/javascript-compiler-in-rust/docs/ast"}},l={},p=[{value:"Token",id:"token",level:2},{value:"Peek",id:"peek",level:2},{value:"Lexing JavaScript",id:"lexing-javascript",level:2},{value:"Identifiers and Unicode",id:"identifiers-and-unicode",level:3},{value:"Token Value",id:"token-value",level:3},{value:"Rust Optimizations",id:"rust-optimizations",level:2},{value:"Smaller Tokens",id:"smaller-tokens",level:3},{value:"String Interning",id:"string-interning",level:3}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"token"},"Token"),(0,a.kt)("p",null,"The lexer, also known as tokenizer or scanner, is responsible for transforming source text into tokens.\nThe tokens will later be consumed by the parser so we don't need to worry about whitespaces and comments from the original text."),(0,a.kt)("p",null,"Let's start simple and transform a single ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," text into a token."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Token {\n    /// Token Type\n    pub kind: Kind,\n\n    /// Start offset in source\n    pub start: usize,\n\n    /// End offset in source\n    pub end: usize,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum Kind {\n    Eof, // end of file\n    Plus,\n}\n")),(0,a.kt)("p",null,"A single ",(0,a.kt)("inlineCode",{parentName:"p"},"+")," will give you ",(0,a.kt)("inlineCode",{parentName:"p"},"[Token { kind: Kind::Plus, start: 0, end: 1 }, Token { kind: Kind::Eof, start: 1, end: 1 }]")),(0,a.kt)("p",null,"To loop through the string, we can either keep track of an index and pretend that we are writing C code,\nor we can take a look at the ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/primitive.str.html#"},"string documentation"),"\nand find ourselves a ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/str/struct.Chars.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Chars"))," iterator to work with."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Chars")," iterator abstracts away the tracking index and boundary checking to make you feel safe."),(0,a.kt)("p",{parentName:"admonition"},"It gives you an ",(0,a.kt)("inlineCode",{parentName:"p"},"Option<char>")," when you call ",(0,a.kt)("inlineCode",{parentName:"p"},"chars.next()"),".\nBut please note that a ",(0,a.kt)("inlineCode",{parentName:"p"},"char")," is not a 0-255 ASCII value,\nit is a utf8 Unicode point value with the range of 0 to 0x10FFFF.")),(0,a.kt)("p",null,"Let's define a starter lexer abstraction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::str::Chars;\n\nstruct Lexer<'a> {\n    /// Source Text\n    source: &'a str,\n\n    /// The remaining characters\n    chars: Chars<'a>\n}\n\nimpl<'a> Lexer<'a> {\n    pub fn new(source: &'a str) -> Self {\n        Self {\n            source,\n            chars: source.chars()\n        }\n    }\n}\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The lifetime ",(0,a.kt)("inlineCode",{parentName:"p"},"'a")," here indicates the iterator has a reference to somewhere, it references to a ",(0,a.kt)("inlineCode",{parentName:"p"},"&'a str")," in this case.")),(0,a.kt)("p",null,"To convert the source text to tokens, just keep calling ",(0,a.kt)("inlineCode",{parentName:"p"},"chars.next()")," and match on the returned ",(0,a.kt)("inlineCode",{parentName:"p"},"char"),"s.\nThe final token will always be ",(0,a.kt)("inlineCode",{parentName:"p"},"Kind::Eof"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"impl<'a> Lexer<'a> {\n    fn read_next_kind(&mut self) -> Kind {\n        while let Some(c) = self.chars.next() {\n            match c {\n              '+' => return Kind::Plus,\n              _ => {}\n            }\n        }\n        Kind::Eof\n    }\n\n    fn read_next_token(&mut self) -> Token {\n        let start = self.offset();\n        let kind = self.read_next_kind();\n        let end = self.offset();\n        Token { kind, start, end }\n    }\n\n    /// Get the length offset from the source, in UTF-8 bytes\n    fn offset(&self) -> usize {\n        self.source.len() - self.current.chars.as_str().len()\n    }\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".len()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},".as_str().len()")," method calls inside ",(0,a.kt)("inlineCode",{parentName:"p"},"fn offset")," feel like O(n), so let's dig deeper."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/src/core/str/iter.rs.html#112"},(0,a.kt)("inlineCode",{parentName:"a"},".as_str()"))," returns a pointer to a string slice"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/rust-lang/rust/blob/b998821e4c51c44a9ebee395c91323c374236bbb/library/core/src/str/iter.rs#L112-L114\n")),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/slice/index.html"},"slice")," is a view into a block of memory represented as a pointer and a length.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},".len()")," method returns the meta data stored inside the slice"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/rust-lang/rust/blob/b998821e4c51c44a9ebee395c91323c374236bbb/library/core/src/str/mod.rs#L157-L159\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/rust-lang/rust/blob/b998821e4c51c44a9ebee395c91323c374236bbb/library/core/src/str/mod.rs#L323-L325\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/rust-lang/rust/blob/b998821e4c51c44a9ebee395c91323c374236bbb/library/core/src/slice/mod.rs#L129-L138\n")),(0,a.kt)("p",null,"All the above code will get compiled into a single data access, so ",(0,a.kt)("inlineCode",{parentName:"p"},".as_str().len()")," is actually O(1).\nZero cost abstraction indeed!"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you are navigating the source code, searching for a definition is simply looking for\n",(0,a.kt)("inlineCode",{parentName:"p"},"fn function_name"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"struct struct_name"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"enum enum_name")," etc.\nThis is one advantage of having constant grammar in Rust.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"peek"},"Peek"),(0,a.kt)("p",null,"To tokenize multi-character operators such as ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"+="),", a helper function called ",(0,a.kt)("inlineCode",{parentName:"p"},"peek")," is needed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"    fn peek(&self) -> Option<char> {\n        self.chars.clone().next()\n    }\n")),(0,a.kt)("p",null,"We don't want to advance the original ",(0,a.kt)("inlineCode",{parentName:"p"},"chars")," iterator so we clone the iterator and advance the index."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"clone")," is cheap if you dig into the ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/src/core/slice/iter.rs.html#148-152"},"source code"),",\nit just copies the tracking and boundary index."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/rust-lang/rust/blob/b998821e4c51c44a9ebee395c91323c374236bbb/library/core/src/slice/iter.rs#L148-L152\n"))),(0,a.kt)("p",null,"Equipped with ",(0,a.kt)("inlineCode",{parentName:"p"},"peek"),", tokenizing ",(0,a.kt)("inlineCode",{parentName:"p"},"++")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"+=")," are just simple nested if statements."),(0,a.kt)("p",null,"Here is a real-world implementation from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mozilla-spidermonkey/jsparagus"},"jsparagus"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"reference",reference:!0},"https://github.com/mozilla-spidermonkey/jsparagus/blob/master/crates/parser/src/lexer.rs#L1769-L1791\n")),(0,a.kt)("p",null,"The above logic applies to all operators, so let's expand our knowledge on lexing JavaScript."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"lexing-javascript"},"Lexing JavaScript"),(0,a.kt)("p",null,"A lexer written in Rust is rather boring, it feels like writing C code\nwhere you write long chained if statements and check for each ",(0,a.kt)("inlineCode",{parentName:"p"},"char")," and then return the respective token."),(0,a.kt)("p",null,"The real fun begins when we start lexing for JavaScript."),(0,a.kt)("p",null,"Let's open up the ",(0,a.kt)("a",{parentName:"p",href:"https://tc39.es/ecma262/"},"ECMAScript Language Specification")," and re-learn JavaScript."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"I still remember the first time I opened up the specification and went into a little corner\nand cried in agony because it feels like reading foreign text with jargons everywhere.\nSo head over to my ",(0,a.kt)("a",{parentName:"p",href:"/blog/ecma-spec"},"guide on reading the specification")," if you ever get lost.")),(0,a.kt)("h3",{id:"identifiers-and-unicode"},"Identifiers and Unicode"),(0,a.kt)("p",null,"We mostly code in ASCII,\nbut ",(0,a.kt)("a",{parentName:"p",href:"https://tc39.es/ecma262/#sec-ecmascript-language-source-code"},"Chapter 11 ECMAScript Language: Source Text"),"\nstates the source text should be in Unicode.\nAnd ",(0,a.kt)("a",{parentName:"p",href:"https://tc39.es/ecma262/#sec-names-and-keywords"},"Chapter 12.6 Names and Keywords"),"\nstates the identifiers are interpreted according to the Default Identifier Syntax given in Unicode Standard Annex #31.\nIn detail:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-markup"},"IdentifierStartChar ::\n    UnicodeIDStart\nIdentifierPartChar ::\n    UnicodeIDContinue\nUnicodeIDStart ::\n    any Unicode code point with the Unicode property \u201cID_Start\u201d\nUnicodeIDContinue ::\n    any Unicode code point with the Unicode property \u201cID_Continue\u201d\n")),(0,a.kt)("p",null,"This means that we can write ",(0,a.kt)("inlineCode",{parentName:"p"},"var \u0ca0_\u0ca0")," but not ",(0,a.kt)("inlineCode",{parentName:"p"},"var \ud83e\udd80"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"\u0ca0_\u0ca0"),' has the Unicode property "ID_Start" while ',(0,a.kt)("inlineCode",{parentName:"p"},"\ud83e\udd80")," does not."),(0,a.kt)("p",null,"I published the ",(0,a.kt)("a",{parentName:"p",href:"https://crates.io/crates/unicode-id-start"},"unicode-id-start")," for this exact purpose,\nand you can call ",(0,a.kt)("inlineCode",{parentName:"p"},"unicode_id_start::is_id_start(char)")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"unicode_id_start::is_id_continue(char)")," in your lexer for checking Unicode."),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"token-value"},"Token Value"),(0,a.kt)("p",null,"We often need to compare numbers and strings in later stages of the compiler,\nbut they are in plain source text right now.\nLet's convert them to Rust types so they are easier to work with."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum Kind {\n    // highlight-next-line\n    Number,\n    // highlight-next-line\n    String,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct Token {\n    // highlight-next-line\n    pub value: TokenValue,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum TokenValue {\n    None,\n    Number(f64),\n    String(String),\n}\n")),(0,a.kt)("p",null,"When we tokenized a string ",(0,a.kt)("inlineCode",{parentName:"p"},'"foo"'),", we get a token with ",(0,a.kt)("inlineCode",{parentName:"p"},"Token { start: 0, end: 2 }"),".\nTo convert it to Rust string, call ",(0,a.kt)("inlineCode",{parentName:"p"},"let s = self.source[token.start..token.end].to_string()"),"\nand save it with ",(0,a.kt)("inlineCode",{parentName:"p"},"token.value = TokenValue::String(s)"),"."),(0,a.kt)("p",null,"When we tokenized a number ",(0,a.kt)("inlineCode",{parentName:"p"},"1.23"),", we get a token with ",(0,a.kt)("inlineCode",{parentName:"p"},"Token { start: 0, end: 3 }"),".\nTo convert it to Rust ",(0,a.kt)("inlineCode",{parentName:"p"},"f64"),", we can use the string ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/primitive.str.html#method.parse"},(0,a.kt)("inlineCode",{parentName:"a"},"parse")),"\nmethod by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"self.source[token.start..token.end].parse::<f64>()"),", and then save the value into ",(0,a.kt)("inlineCode",{parentName:"p"},"token.value"),".\nFor binary, octal and integers, you can learn their parsing techniques from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/mozilla-spidermonkey/jsparagus/blob/master/crates/parser/src/numeric_value.rs"},"jsparagus"),"."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"rust-optimizations"},"Rust Optimizations"),(0,a.kt)("h3",{id:"smaller-tokens"},"Smaller Tokens"),(0,a.kt)("p",null,"It is tempting to put the token values inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"Kind")," enum and aim for simpler and safer code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum Kind {\n    Number(f64),\n    String(String),\n}\n")),(0,a.kt)("p",null,"But it is known that the byte size of a Rust enum is the union of all its variants.\nThis enum packs a lot of bytes compared to the original enum, which has only 1 byte.\nThere will be heavy usages of this ",(0,a.kt)("inlineCode",{parentName:"p"},"Kind")," enum in the parser,\ndealing with a 1 byte enum will obviously be faster than a multi-byte enum."),(0,a.kt)("h3",{id:"string-interning"},"String Interning"),(0,a.kt)("p",null,"It is not performant to use ",(0,a.kt)("inlineCode",{parentName:"p"},"String")," in compilers, mainly due to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"String")," is a heap allocated object"),(0,a.kt)("li",{parentName:"ul"},"String comparison is an O(n) operation")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/String_interning"},"String Interning")," solves this problem by\nstoring only one copy of each distinct string value with a unique identifier in a cache.\nThere will only be one heap allocation per distinct string, and string comparisons becomes O(1)."),(0,a.kt)("p",null,"There are lots of string interning libraries on ",(0,a.kt)("a",{parentName:"p",href:"https://crates.io/search?q=string%20interning"},"crates.io"),"\nwith different props and cons."),(0,a.kt)("p",null,"A starting point is to use ",(0,a.kt)("a",{parentName:"p",href:"https://crates.io/crates/string_cache"},(0,a.kt)("inlineCode",{parentName:"a"},"string-cache")),",\nit has an ",(0,a.kt)("inlineCode",{parentName:"p"},"Atom")," type and a compile time ",(0,a.kt)("inlineCode",{parentName:"p"},'atom!("string")')," interface."),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"TokenValue")," becomes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug, Clone, PartialEq)]\npub enum TokenValue {\n    None,\n    Number(f64),\n    // highlight-next-line\n    String(Atom),\n}\n")),(0,a.kt)("p",null,"and string comparison becomes ",(0,a.kt)("inlineCode",{parentName:"p"},'matches!(token, TokenValue::String(atom!("string")))'),"."))}u.isMDXComponent=!0}}]);