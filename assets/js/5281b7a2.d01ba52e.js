(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[927],{1298:(e,t,r)=>{"use strict";r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>n,metadata:()=>s,toc:()=>u});var o=r(2081),a=(r(9496),r(9613)),i=r(9073);const n={id:"architecture",title:"Architecture Overview"},c=void 0,s={unversionedId:"architecture",id:"architecture",title:"Architecture Overview",description:"For our book, we will be applying the standard compiler frontend phases:",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/javascript-compiler-in-rust/docs/architecture",draft:!1,editUrl:"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/docs/docs/architecture.md",tags:[],version:"current",frontMatter:{id:"architecture",title:"Architecture Overview"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/javascript-compiler-in-rust/docs/intro"},next:{title:"Lexer",permalink:"/javascript-compiler-in-rust/docs/lexer"}},l={},u=[{value:"Performance",id:"performance",level:2}],p={toc:u};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"For our book, we will be applying the standard compiler frontend phases:"),(0,a.kt)(i.Mermaid,{config:{},chart:"flowchart LR;\n    id[Source Text] --\x3e Token --\x3e Lexer --\x3e Parser --\x3e AST",mdxType:"Mermaid"}),(0,a.kt)("p",null,"Writing a JavaScript parser is fairly easy,\nit is 10% architectural decisions and 90% hard work on the fine-grained details."),(0,a.kt)("p",null,"The architectural decisions will mostly affect two categories:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"the performance of your compiler"),(0,a.kt)("li",{parentName:"ul"},"how nice it is to consume your AST")),(0,a.kt)("p",null,"Knowing all the options and trade-offs before building a compiler in Rust will make your whole journey much smoother."),(0,a.kt)("h2",{id:"performance"},"Performance"),(0,a.kt)("p",null,"The key to a performant Rust program is to ",(0,a.kt)("strong",{parentName:"p"},"allocate less memory")," and ",(0,a.kt)("strong",{parentName:"p"},"use fewer CPU cycles"),"."),(0,a.kt)("p",null,"It is mostly transparent where memory allocations are made just by looking for heap-allocated objects such as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Vec")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Box"),".\nReasoning about their usage will give you a sense of how fast your program will be - the more you allocate, you slower your program will be."),(0,a.kt)("p",null,"Rust gives us zero-cost abstraction for free, we don't need to worry too much about abstractions causing slower performance.\nBe careful with your algorithmic complexities and you will be all good to go."),(0,a.kt)("p",null,'If you are unsure about the performance of an API,\ndon\'t be afraid to click the "source" button on the Rust documentation and read the source code,\nthe source code is easy to understand most of the time.'))}d.isMDXComponent=!0},1965:(e,t,r)=>{var o={"./locale":2642,"./locale.js":2642};function a(e){var t=i(e);return r(t)}function i(e){if(!r.o(o,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return o[e]}a.keys=function(){return Object.keys(o)},a.resolve=i,e.exports=a,a.id=1965}}]);