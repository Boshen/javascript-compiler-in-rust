"use strict";(self.webpackChunkjavascript_compiler_in_rust=self.webpackChunkjavascript_compiler_in_rust||[]).push([[377],{9613:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>d});var n=r(9496);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function p(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),m=c(r),d=i,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||a;return r?n.createElement(f,o(o({ref:t},l),{},{components:r})):n.createElement(f,o({ref:t},l))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=m;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:i,o[1]=p;for(var c=2;c<a;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4919:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>p,toc:()=>c});var n=r(2081),i=(r(9496),r(9613));const a={id:"typescript",title:"TypeScript"},o=void 0,p={unversionedId:"typescript",id:"typescript",title:"TypeScript",description:"So you are done with JavaScript and you want to challenge parsing TypeScript?",source:"@site/docs/typescript.md",sourceDirName:".",slug:"/typescript",permalink:"/javascript-compiler-in-rust/docs/typescript",draft:!1,editUrl:"https://github.com/Boshen/javascript-compiler-in-rust/tree/main/docs/docs/typescript.md",tags:[],version:"current",frontMatter:{id:"typescript",title:"TypeScript"},sidebar:"tutorialSidebar",previous:{title:"Semantic Analysis",permalink:"/javascript-compiler-in-rust/docs/semantics_analysis"},next:{title:"References",permalink:"/javascript-compiler-in-rust/docs/references"}},s={},c=[{value:"JSX vs TSX",id:"jsx-vs-tsx",level:2},{value:"Peek for more tokens",id:"peek-for-more-tokens",level:2}],l={toc:c};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"So you are done with JavaScript and you want to challenge parsing TypeScript?\nThe bad news is that there is no specification,\nbut the good news is that the TypeScript compiler is in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/blob/main/src/compiler/parser.ts"},"a single file")," \ud83d\ude43."),(0,i.kt)("h2",{id:"jsx-vs-tsx"},"JSX vs TSX"),(0,i.kt)("p",null,"For the following code,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let foo = <string> bar;\n")),(0,i.kt)("p",null,"It is a syntax error if this is ",(0,i.kt)("inlineCode",{parentName:"p"},"tsx"),' (Unterminated JSX),\nbut it is correct "VariableDeclaration" with ',(0,i.kt)("inlineCode",{parentName:"p"},"TSTypeAssertion"),"."),(0,i.kt)("h2",{id:"peek-for-more-tokens"},"Peek for more tokens"),(0,i.kt)("p",null,"In certain places, the parser need to peek more than one token to determine the correct grammar."),(0,i.kt)("p",null,"For example to parse TSIndexSignature, considier the following two cases:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type A = { readonly [a: number]: string }\n           ^__________________________^ TSIndexSignature\n\ntype B = { [a]: string }\n           ^_________^ TSPropertySignature\n")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"type A")," at the first ",(0,i.kt)("inlineCode",{parentName:"p"},"{"),", we need to peek 5 tokens (",(0,i.kt)("inlineCode",{parentName:"p"},"readonly"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"["),", ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", ",(0,i.kt)("inlineCode",{parentName:"p"},":")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),") in order to make sure\nit is a ",(0,i.kt)("inlineCode",{parentName:"p"},"TSIndexSignature")," and not a ",(0,i.kt)("inlineCode",{parentName:"p"},"TSPropertySignature"),"."),(0,i.kt)("p",null,"To make this possible and efficient, the lexer requires a buffer for storing multiple tokens."))}u.isMDXComponent=!0}}]);